# Вторая часть первой работы

Часть делится ещё на 2 составляющие: на создание функции асинхронного копирования и замеры

## Функция асинхронного копирования

Подразумевается следующее:

1. С помощью `CreateFile` открыть/создать 2 файла: для чтения (откуда копируем) и для записи (куда копируем). Необходимо использовать флаги FILE_FLAG_NO_BUFFERING и FILE_FLAG_OVERLAPPED.

1. После этого, используя `ReadFileEx` и `WriteFileEx` , нужно асинхронно скопировать файл. Причём размер блоков должен равняться размеру кластера (чтобы узнать его используйте `GetDiskFreeSpaceA`), иначе будет бесконечно работать. Здесь же нужно знать, что конец файла можно задавать вручную с помощью `SetFilePointerEx` и `SetEndOfFile`.

1. `SleepEx`... Когда вы запускаете `ReadFileEx или WriteFileEx`, то начинается копирование причём "вне" вашей программы. Когда вы вызываете асинхронное копирование, то вы передаёте ссылку на функцию, которая будет вызвана после завершения копирования. Так вот, чтобы разрешить вызвать эти функции, надо "приостановиться". Для этого и вызывается `SleepEx`.

1. С помощью `TimeGetTime` обеспечить замер времени копирования всего файла. Чтобы использовать `TimeGetTime` нужно подключить библиотеку `libwinmm`.

1. Проверьте на разных файлах, что копирование производится полностью и без повреждений. Для этого можно использовать утилиту `FC`. Или проверять хэш файла, в Windows это делается слудующим образом:

``` bash
> Certutil -hashfile [имя файла]
```

## Замеры

Теперь, когда файл копируется и копируется правильно, нужно провести замеры времени:

- Когда постоянно кол-во перекрывающихся операций ввода-вывода (1 штука), но меняется размер копируемого блока.

- Когда постоянен размер копируемого блока (размер не определён), но меняется  кол-во перекрывающихся операций ввода-вывода.

Для замеров лучше брать файл размера побольше.

# Как запустить эту программу?

В директории, где есть файл `MakeFile` введите команду:

``` bash
> make # или «mingw32-make» если установлен MinGW-64
```

После этого запустите программу:

``` bash
> lab1.2.exe [1] [2] [3] [4] [5] [6] [7] [8]
# 1 - название файла, который будет копироваться. Лучше, чтобы он не был создан.
# Он создастся автоматически
#
# 2 - размер этого файла [1] в байтах. Файл [1] будет забит всяким мусором
# и после создания будет занимать ровно [2] байт.
# Если [2] = 0, то новый файл не создастся,
# а будет использоваться существующий
#
# 3 - название выходного файла
#
# Параметры 4-8 опциональны. 
#
#
#
# При первом замере 
# (когда кол-во перекрывающихся операций = 1 и меняется):
#
# 4 - bs_b: означает, что минимальный размер копируемого блока 
# при асинхронном копировании будет = bs_b * (размер сектора)
#
# 5 - bs_e: означает, что максимальный размер копируемого блока 
# при асинхронном копировании будет = bs_e * (размер сектора)
#
#
#
# При втором замере 
# (размер копируемого блона постоянен 
# и меняется кол-во перекрывающихся операций ввода и вывода):
#
# 6 - bs_std: означает, что при втором замере размер копируемого блока 
# всегда будет = bs_std * (размер сектора)
#
# 7 - thNum_b: означает, что минимальное кол-во перекрывающихся 
# операций ввода и вывода будет = thNum_b
#
# 8 - thNum_e: означает, что максимальное кол-во перекрывающихся 
# операций ввода и вывода будет = thNum_e
#
#
#
# Если параметры [4] - [8] не ввести, 
# то будут использоваться следующие значения:
# bs_b = 1
# bs_e = 70
# bs_std = 16
# thNum_b = 1
# thNum_e = 25
# 
```

После того как программа отработает, вам сгенерируется код для MatLab, который сам построит графики и найдёт минимальное время.